{"meta":{"title":"Kenny's Blog","subtitle":"Stay Hungry,Stay Foolish","description":"这是我的个人博客","author":"Kenny","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"进程与线程","slug":"Java多线程1-进程与线程","date":"2017-08-20T14:35:11.753Z","updated":"2017-08-20T14:47:05.768Z","comments":true,"path":"2017/08/20/Java多线程1-进程与线程/","link":"","permalink":"http://yoursite.com/2017/08/20/Java多线程1-进程与线程/","excerpt":"1.什么是进程?进程是操作系统结构的基础，是一次程序的执行，是系统进行资源分配和调度的一个独立单位。这个解释有点懵了。简单来讲就是一个正在操作系统中的运行的exe程序就是一个进程。","text":"1.什么是进程?进程是操作系统结构的基础，是一次程序的执行，是系统进行资源分配和调度的一个独立单位。这个解释有点懵了。简单来讲就是一个正在操作系统中的运行的exe程序就是一个进程。 2.什么是线程？线程可以理解为是在进程中独立运行的子任务。比如：酷狗音乐.exe运行时,就会有很多子任务在同时运行，包括下载歌词线程，直播线程等 3.线程的优点可以在同一时间内运行更多不同种类的任务，比如作为程序员，我们经常边coding,边听钢琴曲，CPU在不同任务之间飞快切换，导致一种错觉—它们是在同时运行的。 在单任务中，Task1需要花费100s，而Task2必须要等到Task1执行完毕后才能执行，这对Task2来说肯定很不爽，而在多任务中，Task2不必等到Task1完成后再执行，它们是异步的，因此，效率高了。 4.怎样使用线程？实现多线程编程的方式主要有2种，一种是extends Thread，一种是implements Runnable. 1234567891011121314class MyThread extends Thread&#123; @Override public void run() &#123; super.run(); System.out.println(&quot;MyThread&quot;); &#125;&#125;public class Run &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println(&quot;结束运行&quot;); &#125;&#125; 输出: 12结束运行MyThread extends Thread的最大弊端在于不支持多继承，为了实现多继承，可以使用第二种方式implements Runnable.还有，从结果上来看，run方法执行的时间较晚，也就是说，在使用多线程技术时，代码执行结果与代码执行顺序是无关的。 这里有一个坑就是extends Thread的线程多次调用start()方法会报 原因在于一个Thread实例只能启动一个线程. extends Thread 一般不太建议使用，因为单继承原因，而更推荐implements Runnable接口。我们先看一下Thread类的构造函数, 可以看到，可以传递一个Runnable接口，这就好办了，我们可以通过new Thread(Runnable target).start();的方式去启动一个线程了。还有，Thread（Runnable target）不光可以接收一个Runnable接口对象，还可以接收Thread对象(因为Thread implements Runnbale了，多态嘛)，这样做完全可以将一个Thread对象的run()交给其他线程去调用再来看一下Runnable接口有什么方法？ 可以看到，就有唯一的run()，翻译过来的意思是:”当我们implements Runnable时去创建 一个线程时，启动它就会执行run()”，而通过源码得知Thread类其实也implements Runnable,因此我们使用run(). 123456789101112131415class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;MyRunnable&quot;); &#125;&#125;public class Run &#123; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); new Thread(myRunnable).start(); new Thread(myRunnable).start(); new Thread(myRunnable).start(); System.out.println(&quot;结束运行&quot;); &#125;&#125; 这里同样多次调用start()，但程序是可以正常运行的。这是为什么呢？还是刚刚说的那句话一个Thread实例只能启动一个线程，这里3次new Thread，当然不是同一个实例啦。 5.实例变量与线程安全实例变量可以对其他线程有共享和不共享之分。 比如说，我们创建了3个线程，每个线程都有各自的count变量，它们互不影响，这就是变量不共享。共享数据的情况就是多个线程同时访问同一变量，这时往往会出现脏读现象。代码实例: LoginServlet代码: 123456789101112131415161718public class LoginServlet &#123; private static String username; private static String password; public void dopost(String username,String password)&#123; LoginServlet.username = username; if(username.equals(&quot;a&quot;))&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; LoginServlet.password=password; System.out.println(&quot;当前线程名称:&quot;+Thread.currentThread().getName()+&quot;用户名&quot;+LoginServlet.username+&quot;密码&quot;+LoginServlet.password); &#125;&#125; 运行代码: 12345678910111213141516171819202122232425262728293031323334353637class MyThread1 extends Thread &#123; LoginServlet loginServlet; MyThread1(LoginServlet loginServlet) &#123; this.loginServlet = loginServlet; &#125; @Override public void run() &#123; super.run(); loginServlet.dopost(&quot;a&quot;, &quot;aa&quot;); &#125;&#125;class MyThread2 extends Thread &#123; LoginServlet loginServlet; MyThread2(LoginServlet loginServlet) &#123; this.loginServlet = loginServlet; &#125; @Override public void run() &#123; super.run(); loginServlet.dopost(&quot;b&quot;, &quot;bb&quot;); &#125;&#125;public class Run &#123; public static void main(String[] args) &#123; LoginServlet loginServlet = new LoginServlet(); MyThread1 myThread1 = new MyThread1(loginServlet); MyThread2 myThread2 = new MyThread2(loginServlet); myThread1.start(); myThread2.start(); &#125;&#125; 这里出现了脏读现象，可以通过加锁机制，关于synchronized加锁，下次会详细讲解","categories":[],"tags":[]}]}